<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Scrollama Demo: Fixed CSS</title>
	<meta name="description" content="Scrollama Demo: Fixed CSS">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
		/* default / demo page */
		* {
			box-sizing: border-box;
		}
		html,
		body {
			margin: 0;
			padding: 0;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
		}
		body {
			min-height: 1280px;
			font-weight: 300;
			color: #2a2a2a;
		}
		p,
		h1,
		h2,
		h3,
		h4,
		a {
			margin: 0;
			font-weight: 300;
		}
		a,
		a:visited,
		a:hover {
			color: #f30;
			text-decoration: none;
			border-bottom: 1px solid currentColor;
		}
		#intro {
			max-width: 40rem;
			margin: 1rem auto;
			text-align: center;
		}
		.intro__overline {
			font-size: 1.4rem;
		}
		.intro__hed {
			font-size: 1.4rem;
			margin: 1.5rem auto;
			text-transform: uppercase;
			font-weight: 900;
			letter-spacing: 0.05em;
		}
		.intro__dek {
			font-size: 1.4rem;
		}
		/* demo */
		#intro {
			margin-bottom: 320px;
		}
		#outro {
			height: 640px;
		}
		/* scrollama */
		#scroll {
			position: relative;
			border-top: 1px dashed #000;
			border-bottom: 1px dashed #000;
		}
		.scroll__graphic {
			position: absolute;
			top: 0;
			left: 0;
			bottom: auto;
			background-color: #fff;
			-webkit-transform: translate3d(0, 0, 0);
			-moz-transform: translate3d(0, 0, 0);
			transform: translate3d(0, 0, 0);
		}
		.scroll__graphic.is-fixed {
			position: fixed;
		}
		.scroll__graphic.is-bottom {
			bottom: 0;
			top: auto;
		}
		.chart {
			position: absolute;
			right: 1rem;
			top: 75%;
			-moz-transform: translateY(-50%);
			-webkit-transform: translateY(-50%);
			transform: translateY(-50%);
			background-color: #ddd;
			border: 1px solid #000;
		}
        .d3chart {
			position: absolute;
			right: 1rem;
			top: 25%;
			-moz-transform: translateY(-50%);
			-webkit-transform: translateY(-50%);
			transform: translateY(-50%);
			background-color: #ddd;
			border: 1px solid #000;
		}
		.chart p {
			text-align: center;
			padding: 1rem;
			position: absolute;
			top: 50%;
			left: 50%;
			-moz-transform: translate(-50%, -50%);
			-webkit-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
			font-size: 8rem;
			font-weight: 900;
			color: #666;
		}
		.scroll__text {
			position: relative;
			padding: 0 1rem;
			max-width: 30rem;
			width: 33%;
		}
		.step {
			margin: 2rem auto;
			border: 1px solid #333;
		}
		.step.is-active {
			background-color: lightgoldenrodyellow;
		}
		.step p {
			text-align: center;
			padding: 1rem;
			font-size: 1.5rem;
		}
		#cy {
            height: 80%;
            width: 50%;
            float: left;
            position: absolute;
            left: 100;
            top: 100;
        }
	</style>

</head>

<body>
	<section id='intro'>
		<p class='intro__overline'>
			<a href='https://github.com/russellgoldenberg/scrollama'>scrollama.js</a>
		</p>
		<h1 class='intro__hed'>Demo: Sticky Graphic</h1>
		<p class='intro__dek'>
			Start scrolling to see how it works.
		</p>
	</section>
	<section id='scroll'>
		<div class='scroll__graphic'>
			<div class='chart' id="cy">
				<p>0</p>
            </div>
            <div class='d3chart'id="svg">
                
            </div>
		</div>
		<div class='scroll__text'>
			<div class='step'>
				<p>Part 1</p>
				<p>A century ago novelist E M Forster implored us to ‘only connect’. 
					But nowadays it seems that’s all we ever do. 
					But what if amongst all that clicking and swiping and liking there was some deeper structure or pattern. 
					Patterns of connectedness have long fascinated mathematicians just like the rest of us. 
					The realm of mathematics which deals with connectedness is graph theory. 
					But can this arcane realm teach us anything about the real world?
					Can it teach us how to become famous? 
					</p>
			</div>
			<div class='step'>
				<p>A few preliminaries</p>
			</div>
			<div class='step'>
				<p>This is a node</p>
			</div>
			<div class='step'>
				<p>A node in real life could represent person in a social network, a species in a food web or any kind of entity or thing. </p>
			</div>
			<div class='step'>
				<p>This is another node</p>
			</div>
			<div class='step'>
				<p>And this is an edge</p>
			</div>
			<div class='step'>
				<p>In real life, edges are used to represent relationships between people or things. For example an edge between two people in a social network might represent that the two people have liked or followed one another.</p>
			</div>
			<div class='step'>
				<p>By adding more and more nodes and edges to this graph we can generate a larger and more complex graph.</p>
			</div>
			<div class='step'>
				<p>But by so doing it also becomes more difficult to intuit the structure or patterns of connectedness of the graph from a simple visualisation.</p>
			</div>
			<div class='step'>
				<p>Part 2</p>
				<p>Perhaps we could start by analysing some attribute of the nodes or edges or the graph as a whole to generate some insights into the structure of the graph.</p>
			</div>
			<div class='step'>
				<p>One such measure which mathematicians focus on is the degree of a node. This is simply a count of the number of edges that each node has. </p>
			</div>
			<div class='step'>
				<p>This node has [x] edges</p>
			</div>
			<div class='step'>
				<p>While this node has [y] edges</p>
			</div>
			<div class='step'>
				<p>The degree of a node seems intuitively useful as a measure of the relative ‘importance’ of particular nodes in a graph when we consider that nodes with very high degrees or edge counts in real life social networks might be prominent and powerful individuals.</p>
			</div>
			<div class='step'>
				<p>But if we record the degree of each node in the graph we’ll just end up with a big string of numbers. Which is hardly more intuitive than our original graph visualisation. </p>
			</div>
			<div class='step'>
				<p>How about we first figure out how many nodes have zero edges, one edge and so on</p>
			</div>
			<div class='step'>
				<p>And then convert this into a chart</p>
			</div>
			<div class='step'>
				<p>This chart gives us a view of the graph which is complementary to the raw visualisation of the nodes and edges. Further if we consider links to be the ‘currency’ of a graph, it gives us an insight into how equitably such edges are shared out between the different nodes</p>
			</div>
		</div>
	</section>
    <section id='outro'></section>
    <!--<div class='debug'></div>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/2.5.1/cytoscape.min.js"></script>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
    <script src="script.js"></script>
    <script src='https://d3js.org/d3.v4.min.js'></script>
	<script src='https://unpkg.com/intersection-observer'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/scrollama/1.4.1/scrollama.min.js'></script>
	<script>
		// using d3 for convenience
		var container = d3.select('#scroll');
		var graphic = container.select('.scroll__graphic');
		var chart = graphic.select('.chart');
		var text = container.select('.scroll__text');
		var step = text.selectAll('.step');
		// initialize the scrollama
		var scroller = scrollama();
		// generic window resize listener event
		function handleResize() {
			// 1. update height of step elements
			var stepHeight = Math.floor(window.innerHeight * 0.75);
			step.style('height', stepHeight + 'px');
			// 2. update width/height of graphic element
			var bodyWidth = d3.select('body').node().offsetWidth;
			graphic
				.style('width', bodyWidth + 'px')
				.style('height', window.innerHeight + 'px');
			var chartMargin = 32;
			var textWidth = text.node().offsetWidth;
			var chartWidth = graphic.node().offsetWidth - textWidth - chartMargin;
			chart
				.style('width', chartWidth + 'px')
				.style('height', Math.floor(window.innerHeight / 2) + 'px');
			// 3. tell scrollama to update new element dimensions
			scroller.resize();
		}
		// scrollama event handlers
		function handleStepEnter(response) {
			switch (response.index) {
				case 2: 
					addNextNodes(1);
					break;
				case 4: 
					addNextNodes(1);
					break;
				case 5: 
					addLink(0,1);
					break;
				case 7: 
					addNextNodes(5);
					addLinks(10);
					break;
				case 8: 
					addNextNodes(15);
					addLinks(35);
					break;
			}
			console.log(response.index);
			// response = { element, direction, index }
			// // add color to current step only
			// if (response.index === 1) {
			// 	console.log(response);
			// }
			// step.classed('is-active', function (d, i) {
			// 	console.log(response.index);
			// 	return i === response.index;
			// })
			// // update graphic based on step
            // chart.select('p').text(response.index + 1)
            // addOneNodeAndLink();
            getData();
		}
		function handleContainerEnter(response) {
			// response = { direction }
			// sticky the graphic (old school)
			graphic.classed('is-fixed', true);
            graphic.classed('is-bottom', false);
            
		}
		function handleContainerExit(response) {
			// response = { direction }
			// un-sticky the graphic, and pin to top/bottom of container
			graphic.classed('is-fixed', false);
			graphic.classed('is-bottom', response.direction === 'down');
		}
		function init() {
			// 1. force a resize on load to ensure proper dimensions are sent to scrollama
			handleResize();
			// 2. setup the scroller passing options
			// this will also initialize trigger observations
			// 3. bind scrollama event handlers (this can be chained like below)
			scroller.setup({
				container: '#scroll',
				graphic: '.scroll__graphic',
				text: '.scroll__text',
				step: '.scroll__text .step',
                //debug: true,
                //offset: 0.6
			})
				.onStepEnter(handleStepEnter)
				.onContainerEnter(handleContainerEnter)
				.onContainerExit(handleContainerExit);
			// setup resize event
			window.addEventListener('resize', handleResize);
		}
		// kick things off
		init();
    </script>
    <script src="script.js"></script>
    <script src="d3-script.js"></script>
</body>

</html>